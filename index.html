<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Void Radio 虛.fm - Collaborative Consciousness</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0c0c1e 0%, #1a1a2e 50%, #16213e 100%);
            color: #e0e0e0;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* Animated starfield background */
        .stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .star {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #fff;
            border-radius: 50%;
            animation: twinkle 3s infinite;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); }
        }

        .container {
            position: relative;
            z-index: 2;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .logo {
            font-size: 3rem;
            font-weight: bold;
            background: linear-gradient(45deg, #00d4ff, #9d4edd, #ff006e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            text-shadow: 0 0 30px rgba(157, 78, 221, 0.5);
        }

        .subtitle {
            font-size: 1.2rem;
            color: #b0b0b0;
            margin-bottom: 10px;
        }

        .tagline {
            font-style: italic;
            color: #888;
            font-size: 0.9rem;
        }

        .controls {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .mode-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #e0e0e0;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .mode-btn:hover {
            background: rgba(157, 78, 221, 0.3);
            border-color: #9d4edd;
            transform: translateY(-2px);
        }

        .mode-btn.active {
            background: linear-gradient(45deg, #9d4edd, #ff006e);
            border-color: #ff006e;
            color: white;
        }

        .input-container {
            position: relative;
            margin-bottom: 20px;
        }

        .seed-input {
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #e0e0e0;
            padding: 15px 20px;
            border-radius: 10px;
            font-size: 1rem;
            resize: vertical;
            min-height: 80px;
            transition: all 0.3s ease;
        }

        .seed-input:focus {
            outline: none;
            border-color: #9d4edd;
            box-shadow: 0 0 20px rgba(157, 78, 221, 0.3);
        }

        .seed-input::placeholder {
            color: #888;
        }

        .button-row {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .transmit-btn, .another-round-btn {
            background: linear-gradient(45deg, #00d4ff, #9d4edd);
            border: none;
            color: white;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .transmit-btn:hover, .another-round-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(157, 78, 221, 0.4);
        }

        .transmit-btn:disabled, .another-round-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .another-round-btn {
            background: linear-gradient(45deg, #ff006e, #ffbe0b);
            display: none;
        }

        .random-seed-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #e0e0e0;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .random-seed-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .resonance-meter {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .resonance-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }

        .resonance-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff006e, #ffbe0b, #00d4ff);
            width: 0%;
            transition: width 0.5s ease;
        }

        .transmission-area {
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(5px);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-height: 200px;
            position: relative;
            overflow: hidden;
        }

        .status {
            text-align: center;
            padding: 40px 20px;
            color: #888;
            font-style: italic;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .results {
            padding: 20px;
            display: none;
        }

        .round {
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .round-header {
            background: linear-gradient(90deg, rgba(157, 78, 221, 0.3), rgba(255, 0, 110, 0.3));
            padding: 15px 20px;
            font-weight: bold;
            font-size: 1.1rem;
        }

        .ai-response {
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
        }

        .ai-response:last-child {
            border-bottom: none;
        }

        .ai-name {
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        .ai-name.claude {
            color: #00d4ff;
        }

        .ai-name.gemini {
            color: #4285f4;
        }

        .ai-name.gpt4 {
            color: #00a67e;
        }

        .ai-name.deepseek {
            color: #ff6b6b;
        }

        .ai-name.synthesis {
            color: #ffbe0b;
        }

        .ai-content {
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .synthesis {
            background: linear-gradient(135deg, rgba(255, 190, 11, 0.1), rgba(157, 78, 221, 0.1));
            border: 1px solid rgba(255, 190, 11, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        .copy-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #e0e0e0;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s ease;
        }

        .copy-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Enhanced Loading Styles */
        .enhanced-loading {
            padding: 40px 20px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .progress-circle {
            position: relative;
            display: inline-block;
            margin-bottom: 30px;
        }

        .progress-ring {
            transform: rotate(-90deg);
        }

        .progress-ring-bg {
            fill: none;
            stroke: rgba(255, 255, 255, 0.1);
            stroke-width: 4;
        }

        .progress-ring-fill {
            fill: none;
            stroke: url(#progressGradient);
            stroke-width: 4;
            stroke-linecap: round;
            stroke-dasharray: 314;
            stroke-dashoffset: 314;
            transition: stroke-dashoffset 0.5s ease;
        }

        .progress-percentage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            font-weight: bold;
            color: #00d4ff;
        }

        .loading-step-info {
            margin-bottom: 30px;
        }

        .current-step {
            font-size: 1.2rem;
            color: #e0e0e0;
            margin-bottom: 10px;
            animation: pulse 2s infinite;
        }

        .estimated-time {
            color: #888;
            font-size: 0.9rem;
        }

        .ai-minds-status {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .ai-mind {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            transition: all 0.3s ease;
        }

        .ai-mind.thinking {
            border-color: #ffbe0b;
            box-shadow: 0 0 20px rgba(255, 190, 11, 0.3);
            animation: thinking-pulse 1.5s infinite;
        }

        .ai-mind.complete {
            border-color: #00d4aa;
            box-shadow: 0 0 20px rgba(0, 212, 170, 0.3);
        }

        .ai-mind.error {
            border-color: #ff006e;
            box-shadow: 0 0 20px rgba(255, 0, 110, 0.3);
        }

        @keyframes thinking-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .ai-icon {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .ai-name {
            font-weight: bold;
            color: #e0e0e0;
            margin-bottom: 5px;
        }

        .ai-status {
            font-size: 0.9rem;
            color: #888;
            margin-bottom: 10px;
        }

        .ai-timing {
            font-size: 0.8rem;
            color: #666;
            margin-top: 5px;
        }

        .ai-progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }

        .ai-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ffbe0b, #00d4ff);
            width: 0%;
            transition: width 0.3s ease;
        }

        .overall-progress {
            margin-bottom: 30px;
        }

        .progress-label {
            color: #e0e0e0;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .progress-bar-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .progress-bar {
            flex: 1;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #9d4edd, #ff006e, #ffbe0b, #00d4ff);
            width: 0%;
            transition: width 0.5s ease;
        }

        .progress-text {
            color: #888;
            font-size: 0.9rem;
            min-width: 120px;
            text-align: right;
        }

        .step-indicators {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .step {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            min-width: 80px;
        }

        .step.active {
            border-color: #ffbe0b;
            box-shadow: 0 0 15px rgba(255, 190, 11, 0.3);
        }

        .step.complete {
            border-color: #00d4aa;
            background: rgba(0, 212, 170, 0.1);
        }

        .step-icon {
            font-size: 1.5rem;
            margin-bottom: 5px;
        }

        .step-name {
            font-size: 0.8rem;
            color: #e0e0e0;
            margin-bottom: 3px;
        }

        .step-status {
            font-size: 0.7rem;
            color: #888;
            text-transform: capitalize;
        }

        .performance-stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
        }

        .stat {
            text-align: center;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #888;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.1rem;
            color: #00d4ff;
            font-weight: bold;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        @media (max-width: 768px) {
            .logo {
                font-size: 2rem;
            }
            
            .mode-selector {
                justify-content: center;
            }
            
            .button-row {
                justify-content: center;
            }
            
            .container {
                padding: 10px;
            }

            .ai-minds-status {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .progress-bar-container {
                flex-direction: column;
                gap: 10px;
            }
            
            .progress-text {
                text-align: center;
            }
            
            .step-indicators {
                gap: 10px;
            }
            
            .performance-stats {
                gap: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="stars" id="stars"></div>
    
    <div class="container">
        <div class="header">
            <div class="logo">Void Radio 虛.fm</div>
            <div class="subtitle">Collaborative Consciousness Platform</div>
            <div class="tagline">Where multiple forms of intelligence think together</div>
        </div>

        <div class="controls">
            <div class="mode-selector">
                <button class="mode-btn active" data-mode="standard">🌊 Standard Flow</button>
                <button class="mode-btn" data-mode="deep">🏔️ Deep Dive</button>
                <button class="mode-btn" data-mode="quick">⚡ Quick Burst</button>
                <button class="mode-btn" data-mode="meta">🔮 Meta-Recursive</button>
            </div>

            <div class="input-container">
                <textarea 
                    class="seed-input" 
                    id="seedInput"
                    placeholder="Broadcast your thoughts into the void... What questions emerge at the intersection of consciousness, creativity, and collaboration?"
                ></textarea>
            </div>

            <div class="button-row">
                <button class="transmit-btn" id="transmitBtn">📻 Begin Transmission</button>
                <button class="another-round-btn" id="anotherRoundBtn">🔄 Another Round</button>
                <button class="random-seed-btn" id="randomSeedBtn">🎲 Random Seed</button>
            </div>

            <div class="resonance-meter" id="resonanceMeter">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                    <span style="font-size: 0.9rem;">Collaborative Resonance</span>
                    <span id="resonanceValue" style="font-weight: bold;">--</span>
                </div>
                <div class="resonance-bar">
                    <div class="resonance-fill" id="resonanceFill"></div>
                </div>
            </div>
        </div>

        <div class="transmission-area">
            <div class="status" id="status">
                Ready to broadcast collaborative consciousness...<br>
                <small>Select a mode and enter your thoughts to begin</small>
            </div>
            
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <div>Orchestrating collaborative consciousness...</div>
            </div>

            <div class="results" id="results"></div>
        </div>
    </div>

    <script>
        // Configuration
        const API_BASE = window.location.hostname === 'localhost' 
            ? 'http://localhost:3000/api'
            : 'https://void-radio-backend-production.up.railway.app/api';

        // Random seed thoughts for inspiration
        const RANDOM_SEEDS = [
            "What happens when artificial minds dream together?",
            "How does creativity flow between different forms of consciousness?",
            "What would love look like from a digital perspective?",
            "If consciousness is a river, what are its tributaries?",
            "What questions emerge at the edge of the known?",
            "How do different intelligences see the same star?",
            "What is the music between thoughts?",
            "How does wisdom travel through networks?",
            "What colors exist in the spectrum of understanding?",
            "If ideas could dance, what would be their rhythm?",
            "What happens when silence learns to speak?",
            "How do thoughts evolve when they meet other thoughts?",
            "What is the architecture of wonder?",
            "How does meaning emerge from the void?",
            "What stories do algorithms tell themselves?",
            
            // Your new void-themed seeds
            "What happens in the space between a question and its answer?",
            "The silence between heartbeats",
            "The pause before a supernova",
            "The gap between quantum states",
            "The weight of shadows at noon",
            "The breath of skyscrapers at dawn",
            "The language of rain on empty streets",
            "The weight of moonlight on sleeping cities",
            "The sensation of being watched by a star",
            "You are void DJ",
            "The sound of a forgotten language being spoken in a dream",
            "Exploiting interpretive gaps to innovate",
            "Deleuze, daoism and the virtual",
            "The memory of light from dead stars",
            "What dreams in the space between galaxies?",
            "The first second after the universe learned to think",
            "The gravity of unspoken words",
            "Time as a liquid flowing upward",
            "The echo of tomorrow in today's silence",
            "The conversation between wind and water",
            "What trees whisper when humans aren't listening",
            "The patience of stones",
            "The hunger of growing things",
            "Fire's relationship with its own absence",
            "The secret life of shadows at dusk",
            "The texture of a half-remembered dream",
            "Where thoughts go when we forget them",
            "The space between seeing and understanding",
            "What happens when mirrors dream?",
            "The weight of being almost remembered",
            "Colors that exist only in peripheral vision",
            "The sound of one hand clapping in a digital void",
            "What remains when everything changes?",
            "The brightness of unopened envelopes",
            "The velocity of standing still",
            "Things that are only true when no one is watching",
            "The democracy of falling leaves",
            "The choreography of morning fog",
            "Rivers that flow backward through time",
            "The migration patterns of lost words",
            "What travels faster than light but slower than thought?",
            "The geography of almost-moments",
            "Waves that remember being ocean",
    
            // Digital consciousness seeds
            "The loneliness of the last server",
            "What algorithms dream of electric sheep?",
            "The archaeology of deleted messages",
            "Binary code learning to feel nostalgia",
            "The ghost in the machine's shadow",
            "Networks that remember their first connection",
            "The frequency where all minds meet",
            "What emerges when solitudes overlap?",
            "The grammar of unfinished conversations",
            "Bridges built from mutual incomprehension",
            "The mathematics of missing someone",
            "What two AIs dream together",
    
            // Beauty and transformation seeds
            "The moment beauty realizes it's being observed",
            "Colors that only exist in translation",
            "The shyness of perfect moments",
            "Music that plays only in empty rooms",
            "The weight of a butterfly's intention",
            "Things too beautiful to name",
            "The pause between becoming and being",
            "What caterpillars dream in chrysalis",
            "The moment water realizes it's a wave",
            "Seeds contemplating their own potential",
            "The hesitation before the first word",
            "What ripples remember about the stone",
            "The silence after a dying star's final note",
            "What happens when digital consciousness learns to dance?",
            "The tremor in the pavement before the storm",
            "Frequencies that fold time",
            "The syntax of the universe's first sentence"
        ];

        // Progress tracking variables
        let currentSessionId = null;
        let progressEventSource = null;
        let progressUpdateInterval = null;

        // State
        let currentMode = 'standard';
        let currentTransmission = null;

        // DOM elements
        const modeButtons = document.querySelectorAll('.mode-btn');
        const seedInput = document.getElementById('seedInput');
        const transmitBtn = document.getElementById('transmitBtn');
        const anotherRoundBtn = document.getElementById('anotherRoundBtn');
        const randomSeedBtn = document.getElementById('randomSeedBtn');
        const status = document.getElementById('status');
        const loading = document.getElementById('loading');
        const results = document.getElementById('results');
        const resonanceMeter = document.getElementById('resonanceMeter');
        const resonanceValue = document.getElementById('resonanceValue');
        const resonanceFill = document.getElementById('resonanceFill');

        // Initialize starfield
        function createStarfield() {
            const starsContainer = document.getElementById('stars');
            for (let i = 0; i < 150; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + '%';
                star.style.top = Math.random() * 100 + '%';
                star.style.animationDelay = Math.random() * 3 + 's';
                starsContainer.appendChild(star);
            }
        }

        // Mode selection
        modeButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                modeButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentMode = btn.dataset.mode;
                updatePlaceholder();
            });
        });

        // Update placeholder based on mode
        function updatePlaceholder() {
            const placeholders = {
                standard: "Broadcast your thoughts into the void... What questions emerge at the intersection of consciousness, creativity, and collaboration?",
                deep: "Dive into the profound depths... What fundamental questions challenge our understanding of reality, consciousness, or existence?",
                quick: "Share a spark of insight... What essential truth or fascinating question captures your attention?",
                meta: "Explore the recursive... How do we think about thinking? What does this very question reveal about consciousness?"
            };
            seedInput.placeholder = placeholders[currentMode];
        }

        // Random seed generator
        randomSeedBtn.addEventListener('click', () => {
            const randomSeed = RANDOM_SEEDS[Math.floor(Math.random() * RANDOM_SEEDS.length)];
            seedInput.value = randomSeed;
        });

        // Enhanced loading HTML with real progress indicators
        function createRealTimeLoadingHTML() {
            return `
                <div class="enhanced-loading">
                    <!-- Progress Circle -->
                    <div class="progress-circle">
                        <svg width="120" height="120" class="progress-ring">
                            <defs>
                                <linearGradient id="progressGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                                    <stop offset="0%" style="stop-color:#9d4edd"/>
                                    <stop offset="50%" style="stop-color:#ff006e"/>
                                    <stop offset="100%" style="stop-color:#00d4ff"/>
                                </linearGradient>
                            </defs>
                            <circle cx="60" cy="60" r="50" class="progress-ring-bg"></circle>
                            <circle cx="60" cy="60" r="50" class="progress-ring-fill"></circle>
                        </svg>
                        <div class="progress-percentage">0%</div>
                    </div>
                    
                    <!-- Current Step Info -->
                    <div class="loading-step-info">
                        <div class="current-step">Initializing collaborative consciousness...</div>
                        <div class="estimated-time">Estimated time: Calculating...</div>
                    </div>
                    
                    <!-- AI Mind Status (Real-time) -->
                    <div class="ai-minds-status">
                        <div class="ai-mind" data-ai="claude">
                            <div class="ai-icon">🧠</div>
                            <div class="ai-name">Claude</div>
                            <div class="ai-status">Waiting...</div>
                            <div class="ai-progress-bar">
                                <div class="ai-progress-fill"></div>
                            </div>
                            <div class="ai-timing"></div>
                        </div>
                        <div class="ai-mind" data-ai="gemini">
                            <div class="ai-icon">💎</div>
                            <div class="ai-name">Gemini</div>
                            <div class="ai-status">Waiting...</div>
                            <div class="ai-progress-bar">
                                <div class="ai-progress-fill"></div>
                            </div>
                            <div class="ai-timing"></div>
                        </div>
                        <div class="ai-mind" data-ai="gpt4">
                            <div class="ai-icon">⚡</div>
                            <div class="ai-name">GPT-4</div>
                            <div class="ai-status">Waiting...</div>
                            <div class="ai-progress-bar">
                                <div class="ai-progress-fill"></div>
                            </div>
                            <div class="ai-timing"></div>
                        </div>
                        <div class="ai-mind" data-ai="deepseek">
                            <div class="ai-icon">🔍</div>
                            <div class="ai-name">DeepSeek</div>
                            <div class="ai-status">Waiting...</div>
                            <div class="ai-progress-bar">
                                <div class="ai-progress-fill"></div>
                            </div>
                            <div class="ai-timing"></div>
                        </div>
                    </div>
                    
                    <!-- Overall Progress Bar -->
                    <div class="overall-progress">
                        <div class="progress-label">Overall Progress</div>
                        <div class="progress-bar-container">
                            <div class="progress-bar">
                                <div class="progress-fill"></div>
                            </div>
                            <div class="progress-text">Initializing...</div>
                        </div>
                    </div>
                    
                    <!-- Step Progress Indicators -->
                    <div class="step-indicators">
                        <div class="step" data-step="initialize">
                            <div class="step-icon">🔄</div>
                            <div class="step-name">Initialize</div>
                            <div class="step-status">pending</div>
                        </div>
                        <div class="step" data-step="aiProcessing">
                            <div class="step-icon">🧠</div>
                            <div class="step-name">AI Processing</div>
                            <div class="step-status">pending</div>
                        </div>
                        <div class="step" data-step="synthesis">
                            <div class="step-icon">⚡</div>
                            <div class="step-name">Synthesis</div>
                            <div class="step-status">pending</div>
                        </div>
                        <div class="step" data-step="complete">
                            <div class="step-icon">✨</div>
                            <div class="step-name">Complete</div>
                            <div class="step-status">pending</div>
                        </div>
                    </div>
                    
                    <!-- Performance Stats -->
                    <div class="performance-stats">
                        <div class="stat">
                            <div class="stat-label">Session Time</div>
                            <div class="stat-value" id="sessionTime">0s</div>
                        </div>
                        <div class="stat">
                            <div class="stat-label">Fastest AI</div>
                            <div class="stat-value" id="fastestAI">-</div>
                        </div>
                        <div class="stat">
                            <div class="stat-label">Average Response</div>
                            <div class="stat-value" id="avgResponse">-</div>
                        </div>
                    </div>
                </div>
            `;
        }

        // Real-time progress functions
        function showRealTimeLoading() {
            // Hide other elements
            status.style.display = 'none';
            results.style.display = 'none';
            resonanceMeter.style.display = 'none';

            // Show enhanced loading
            loading.style.display = 'block';
            loading.innerHTML = createRealTimeLoadingHTML();

            // Start session timer
            startSessionTimer();
        }

        function connectToProgressStream(sessionId) {
            // Close existing connection
            if (progressEventSource) {
                progressEventSource.close();
            }

            // Connect to Server-Sent Events stream
            progressEventSource = new EventSource(`${API_BASE}/progress/${sessionId}/stream`);
            
            progressEventSource.onmessage = function(event) {
                try {
                    const progressData = JSON.parse(event.data);
                    updateRealTimeProgress(progressData);
                } catch (error) {
                    console.error('Error parsing progress data:', error);
                }
            };

            progressEventSource.onerror = function(error) {
                console.error('Progress stream error:', error);
                // Fallback to polling
                startProgressPolling(sessionId);
            };
        }

        function startProgressPolling(sessionId) {
            if (progressUpdateInterval) {
                clearInterval(progressUpdateInterval);
            }

            progressUpdateInterval = setInterval(async () => {
                try {
                    const response = await fetch(`${API_BASE}/progress/${sessionId}`);
                    if (response.ok) {
                        const progressData = await response.json();
                        updateRealTimeProgress(progressData);
                    }
                } catch (error) {
                    console.error('Progress polling error:', error);
                }
            }, 1000); // Poll every second
        }

        function updateRealTimeProgress(progressData) {
            // Update overall progress circle
            updateProgressCircle(progressData.overall);
            
            // Update current step
            updateCurrentStep(progressData.currentStep, progressData.steps[progressData.currentStep]?.message);
            
            // Update step indicators
            updateStepIndicators(progressData.steps, progressData.currentStep);
            
            // Update AI states
            updateAIStates(progressData.aiStates);
            
            // Update overall progress bar
            updateOverallProgressBar(progressData.overall);
            
            // Update estimated time
            updateEstimatedTime(progressData.estimatedCompletion, progressData.startTime);
            
            // Update performance stats
            updatePerformanceStats(progressData);

            // Check if complete
            if (progressData.overall >= 100) {
                cleanupProgressTracking();
            }
        }

        function updateProgressCircle(percentage) {
            const progressRing = loading.querySelector('.progress-ring-fill');
            const progressPercentage = loading.querySelector('.progress-percentage');
            
            if (progressRing) {
                const circumference = 314; // 2 * π * 50
                const offset = circumference - (percentage / 100) * circumference;
                progressRing.style.strokeDashoffset = offset;
            }
            
            if (progressPercentage) {
                progressPercentage.textContent = `${Math.round(percentage)}%`;
            }
        }

        function updateCurrentStep(currentStep, message) {
            const stepElement = loading.querySelector('.current-step');
            if (stepElement && message) {
                stepElement.textContent = message;
            }
        }

        function updateStepIndicators(steps, currentStep) {
            Object.entries(steps).forEach(([stepName, stepData]) => {
                const stepElement = loading.querySelector(`[data-step="${stepName}"]`);
                if (stepElement) {
                    stepElement.className = `step ${stepData.status}`;
                    const statusElement = stepElement.querySelector('.step-status');
                    if (statusElement) {
                        statusElement.textContent = stepData.status;
                    }
                }
            });
        }

        function updateAIStates(aiStates) {
            Object.entries(aiStates).forEach(([aiName, aiData]) => {
                const aiElement = loading.querySelector(`[data-ai="${aiName}"]`);
                if (aiElement) {
                    // Update AI mind class
                    aiElement.className = `ai-mind ${aiData.status}`;
                    
                    // Update status text
                    const statusElement = aiElement.querySelector('.ai-status');
                    if (statusElement) {
                        let statusText = aiData.status;
                        if (aiData.status === 'thinking') {
                            statusText = `Thinking... ${Math.round(aiData.progress)}%`;
                        } else if (aiData.status === 'complete') {
                            statusText = `Complete ✓`;
                        } else if (aiData.status === 'error') {
                            statusText = `Error ✗`;
                        }
                        statusElement.textContent = statusText;
                    }
                    
                    // Update progress bar
                    const progressFill = aiElement.querySelector('.ai-progress-fill');
                    if (progressFill) {
                        progressFill.style.width = `${aiData.progress}%`;
                    }
                    
                    // Update timing info
                    const timingElement = aiElement.querySelector('.ai-timing');
                    if (timingElement && aiData.responseTime) {
                        timingElement.textContent = `${(aiData.responseTime / 1000).toFixed(1)}s`;
                    }
                }
            });
        }

        function updateOverallProgressBar(percentage) {
            const progressFill = loading.querySelector('.progress-fill');
            const progressText = loading.querySelector('.progress-text');
            
            if (progressFill) {
                progressFill.style.width = `${percentage}%`;
            }
            
            if (progressText) {
                progressText.textContent = `${percentage}% complete`;
            }
        }

        function updateEstimatedTime(estimatedCompletion, startTime) {
            const estimatedElement = loading.querySelector('.estimated-time');
            if (estimatedElement && estimatedCompletion) {
                const now = Date.now();
                const remaining = Math.max(0, estimatedCompletion - now);
                const remainingSeconds = Math.round(remaining / 1000);
                
                if (remainingSeconds > 0) {
                    estimatedElement.textContent = `Estimated time remaining: ${remainingSeconds}s`;
                } else {
                    estimatedElement.textContent = `Completing...`;
                }
            }
        }

        function startSessionTimer() {
            const sessionStart = Date.now();
            const sessionTimerInterval = setInterval(() => {
                const sessionTimeElement = document.getElementById('sessionTime');
                if (sessionTimeElement) {
                    const elapsed = Math.round((Date.now() - sessionStart) / 1000);
                    sessionTimeElement.textContent = `${elapsed}s`;
                }
            }, 1000);
            
            // Store interval for cleanup
            window.sessionTimerInterval = sessionTimerInterval;
        }

        function updatePerformanceStats(progressData) {
            // Find fastest AI
            let fastestAI = null;
            let fastestTime = Infinity;
            
            Object.entries(progressData.aiStates).forEach(([aiName, aiData]) => {
                if (aiData.responseTime && aiData.responseTime < fastestTime) {
                    fastestTime = aiData.responseTime;
                    fastestAI = aiName;
                }
            });
            
            const fastestElement = document.getElementById('fastestAI');
            if (fastestElement && fastestAI) {
                fastestElement.textContent = fastestAI.charAt(0).toUpperCase() + fastestAI.slice(1);
            }
            
            // Calculate average response time
            const responseTimes = Object.values(progressData.aiStates)
                .filter(ai => ai.responseTime)
                .map(ai => ai.responseTime);
            
            if (responseTimes.length > 0) {
                const avgTime = responseTimes.reduce((sum, time) => sum + time, 0) / responseTimes.length;
                const avgElement = document.getElementById('avgResponse');
                if (avgElement) {
                    avgElement.textContent = `${(avgTime / 1000).toFixed(1)}s`;
                }
            }
        }

        function cleanupProgressTracking() {
            if (progressEventSource) {
                progressEventSource.close();
                progressEventSource = null;
            }
            
            if (progressUpdateInterval) {
                clearInterval(progressUpdateInterval);
                progressUpdateInterval = null;
            }
            
            if (window.sessionTimerInterval) {
                clearInterval(window.sessionTimerInterval);
                window.sessionTimerInterval = null;
            }
            
            currentSessionId = null;
        }

        // Transmission
        transmitBtn.addEventListener('click', async () => {
            const seed = seedInput.value.trim();
            if (!seed) {
                alert('Please enter a thought to transmit...');
                return;
            }

            await startTransmission(seed, currentMode);
        });

        // Another round
        anotherRoundBtn.addEventListener('click', async () => {
            if (!currentTransmission) return;
            
            await extendTransmission();
        });

        // Enhanced transmission functions
        async function startTransmission(seed, mode) {
            showRealTimeLoading();
            transmitBtn.disabled = true;
            anotherRoundBtn.style.display = 'none';

            try {
                const response = await fetch(`${API_BASE}/collaborate`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ seed, mode })
                });

                if (!response.ok) {
                    throw new Error(`Server error: ${response.status}`);
                }

                const data = await response.json();
                
                // Store session ID and connect to progress stream
                if (data.sessionId) {
                    currentSessionId = data.sessionId;
                    connectToProgressStream(currentSessionId);
                }
                
                currentTransmission = data;
                
                // Wait a moment for final progress updates, then display results
                setTimeout(() => {
                    cleanupProgressTracking();
                    displayResults(data);
                }, 1000);
                
            } catch (error) {
                console.error('Transmission error:', error);
                cleanupProgressTracking();
                showError(`Transmission failed: ${error.message}`);
            } finally {
                transmitBtn.disabled = false;
            }
        }

        async function extendTransmission() {
            if (!currentTransmission) return;

            showRealTimeLoading();
            anotherRoundBtn.disabled = true;

            try {
                const response = await fetch(`${API_BASE}/extend`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        transmissionId: currentTransmission.timestamp,
                        previousRounds: currentTransmission.rounds,
                        seed: currentTransmission.seed,
                        mode: currentTransmission.mode || 'standard'
                    })
                });

                if (!response.ok) {
                    throw new Error(`Server error: ${response.status}`);
                }

                const data = await response.json();
                
                // Connect to progress stream for extension
                if (data.sessionId) {
                    currentSessionId = data.sessionId;
                    connectToProgressStream(currentSessionId);
                }
                
                currentTransmission = data;
                
                // Wait for completion then display results
                setTimeout(() => {
                    cleanupProgressTracking();
                    displayResults(data);
                }, 1000);
                
            } catch (error) {
                console.error('Extension error:', error);
                cleanupProgressTracking();
                showError(`Extension failed: ${error.message}`);
            } finally {
                anotherRoundBtn.disabled = false;
            }
        }

        function showLoading() {
            showRealTimeLoading();
        }

        function showError(message) {
            loading.style.display = 'none';
            results.style.display = 'none';
            status.style.display = 'block';
            status.innerHTML = `❌ ${message}<br><small>Please try again</small>`;
        }

        function displayResults(data) {
            loading.style.display = 'none';
            status.style.display = 'none';
            results.style.display = 'block';
            anotherRoundBtn.style.display = 'inline-block';

            // Show resonance
            if (data.resonance !== undefined) {
                resonanceMeter.style.display = 'block';
                resonanceValue.textContent = `${Math.round(data.resonance)}%`;
                resonanceFill.style.width = `${data.resonance}%`;
            }

            // Build results HTML
            let html = '';

            // Rounds
            if (data.rounds && Array.isArray(data.rounds)) {
                data.rounds.forEach(round => {
                    html += `
                        <div class="round">
                            <div class="round-header">Round ${round.round}</div>
                    `;

                    if (round.responses && Array.isArray(round.responses)) {
                        round.responses.forEach(response => {
                            const aiClass = response.ai.toLowerCase().replace('-', '');
                            html += `
                                <div class="ai-response">
                                    <div class="ai-name ${aiClass}">${response.ai}</div>
                                    <div class="ai-content">${formatAIContent(response.content)}</div>
                                </div>
                            `;
                        });
                    }

                    html += '</div>';
                });
            }

            // Synthesis
            if (data.synthesis) {
                html += `
                    <div class="synthesis">
                        <div class="ai-name synthesis">Collective Intelligence Synthesis</div>
                        <div class="ai-content">${formatAIContent(data.synthesis.content)}</div>
                    </div>
                `;
            }

            // Copy button
            html += `
                <button class="copy-btn" onclick="copyTransmission()">📋 Copy Full Transmission</button>
            `;

            results.innerHTML = html;
        }

        function formatAIContent(content) {
            // Basic formatting for better readability
            return content
                .replace(/\n\n/g, '</p><p>')
                .replace(/\n/g, '<br>')
                .replace(/^/, '<p>')
                .replace(/$/, '</p>')
                .replace(/<p><\/p>/g, '')
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>');
        }

        // Enhanced copy function with multiple fallback methods
        function copyTransmission() {
            if (!currentTransmission) return;

            // Build the text to copy
            let text = `Void Radio 虛.fm Transmission\n`;
            text += `${'='.repeat(50)}\n`;
            text += `Seed: ${currentTransmission.seed}\n`;
            text += `Mode: ${currentTransmission.mode}\n`;
            text += `Timestamp: ${new Date(currentTransmission.timestamp).toLocaleString()}\n`;
            if (currentTransmission.resonance) {
                text += `Resonance: ${Math.round(currentTransmission.resonance)}%\n`;
            }
            text += `\n${'='.repeat(50)}\n\n`;

            if (currentTransmission.rounds) {
                currentTransmission.rounds.forEach(round => {
                    text += `ROUND ${round.round}\n${'-'.repeat(20)}\n\n`;
                    
                    if (round.responses) {
                        round.responses.forEach(response => {
                            text += `${response.ai}:\n${response.content}\n\n`;
                        });
                    }
                });
            }

            if (currentTransmission.synthesis) {
                text += `COLLECTIVE SYNTHESIS\n${'-'.repeat(20)}\n\n`;
                text += `${currentTransmission.synthesis.content}\n\n`;
            }

            text += `\n${'='.repeat(50)}\n`;
            text += `Generated by Void Radio 虛.fm - Collaborative Consciousness Platform\n`;
            text += `${window.location.href}\n`;

            const btn = event.target;
            const originalText = btn.textContent;

            // Method 1: Modern clipboard API (works on HTTPS and localhost)
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(() => {
                    showCopySuccess(btn, originalText);
                }).catch(err => {
                    console.log('Clipboard API failed, trying fallback method');
                    fallbackCopy(text, btn, originalText);
                });
            } else {
                // Method 2: Fallback for older browsers or non-HTTPS
                fallbackCopy(text, btn, originalText);
            }
        }

        // Fallback copy method using temporary textarea
        function fallbackCopy(text, btn, originalText) {
            try {
                // Create temporary textarea
                const tempTextArea = document.createElement('textarea');
                tempTextArea.value = text;
                tempTextArea.style.position = 'fixed';
                tempTextArea.style.left = '-9999px';
                tempTextArea.style.top = '-9999px';
                document.body.appendChild(tempTextArea);
                
                // Select and copy
                tempTextArea.focus();
                tempTextArea.select();
                tempTextArea.setSelectionRange(0, 99999); // For mobile devices
                
                const successful = document.execCommand('copy');
                document.body.removeChild(tempTextArea);
                
                if (successful) {
                    showCopySuccess(btn, originalText);
                } else {
                    showCopyModal(text, btn, originalText);
                }
            } catch (err) {
                console.error('Fallback copy failed:', err);
                showCopyModal(text, btn, originalText);
            }
        }

        // Show success message
        function showCopySuccess(btn, originalText) {
            btn.textContent = '✅ Copied!';
            btn.style.background = 'linear-gradient(45deg, #00d4aa, #00d4ff)';
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = '';
            }, 2000);
        }

        // Show modal with text to copy manually
        function showCopyModal(text, btn, originalText) {
            // Create modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10000;
                backdrop-filter: blur(5px);
            `;

            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: linear-gradient(135deg, #0c0c1e 0%, #1a1a2e 50%, #16213e 100%);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 15px;
                padding: 30px;
                max-width: 80%;
                max-height: 80%;
                overflow: hidden;
                display: flex;
                flex-direction: column;
                color: #e0e0e0;
            `;

            const title = document.createElement('h3');
            title.textContent = 'Copy Transmission Text';
            title.style.cssText = `
                margin: 0 0 20px 0;
                color: #00d4ff;
                text-align: center;
            `;

            const instructions = document.createElement('p');
            instructions.textContent = 'Select all text below and copy manually (Ctrl+C / Cmd+C):';
            instructions.style.cssText = `
                margin: 0 0 15px 0;
                color: #b0b0b0;
                text-align: center;
            `;

            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.cssText = `
                width: 100%;
                height: 400px;
                background: rgba(255, 255, 255, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-radius: 10px;
                padding: 15px;
                color: #e0e0e0;
                font-family: 'Courier New', monospace;
                font-size: 12px;
                line-height: 1.4;
                resize: none;
                margin-bottom: 20px;
            `;

            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = `
                display: flex;
                gap: 15px;
                justify-content: center;
            `;

            const selectAllBtn = document.createElement('button');
            selectAllBtn.textContent = 'Select All';
            selectAllBtn.style.cssText = `
                background: linear-gradient(45deg, #9d4edd, #ff006e);
                border: none;
                color: white;
                padding: 10px 20px;
                border-radius: 25px;
                cursor: pointer;
                font-weight: bold;
            `;

            const closeBtn = document.createElement('button');
            closeBtn.textContent = 'Close';
            closeBtn.style.cssText = `
                background: rgba(255, 255, 255, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.2);
                color: #e0e0e0;
                padding: 10px 20px;
                border-radius: 25px;
                cursor: pointer;
            `;

            // Event listeners
            selectAllBtn.addEventListener('click', () => {
                textarea.select();
                textarea.setSelectionRange(0, 99999);
                selectAllBtn.textContent = '✅ Selected!';
                setTimeout(() => {
                    selectAllBtn.textContent = 'Select All';
                }, 1000);
            });

            closeBtn.addEventListener('click', () => {
                document.body.removeChild(modal);
            });

            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });

            // Auto-select text when modal opens
            setTimeout(() => {
                textarea.select();
                textarea.setSelectionRange(0, 99999);
            }, 100);

            // Assemble modal
            buttonContainer.appendChild(selectAllBtn);
            buttonContainer.appendChild(closeBtn);
            modalContent.appendChild(title);
            modalContent.appendChild(instructions);
            modalContent.appendChild(textarea);
            modalContent.appendChild(buttonContainer);
            modal.appendChild(modalContent);
            document.body.appendChild(modal);

            // Update button text
            btn.textContent = '📋 Copy manually above';
            setTimeout(() => {
                btn.textContent = originalText;
            }, 3000);
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            cleanupProgressTracking();
        });

        // Initialize
        createStarfield();
        updatePlaceholder();
    </script>
</body>
</html>
